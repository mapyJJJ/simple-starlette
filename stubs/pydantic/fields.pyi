from typing import Any, Callable, ClassVar, Dict, Iterable, Iterator, List, Optional, Tuple, Union

import pydantic.errors
import pydantic.utils
import typing
Any: typing._SpecialForm
DefaultDict: typing._GenericAlias
Deque: typing._GenericAlias
Dict: typing._GenericAlias
Field: cython_function_or_method
FrozenSet: typing._GenericAlias
Generator: typing._GenericAlias
Iterable: typing._GenericAlias
Iterator: typing._GenericAlias
List: typing._GenericAlias
MAPPING_LIKE_SHAPES: set
Mapping: typing._GenericAlias
NONE_TYPES: set
NoArgAnyCallable: typing._GenericAlias
Optional: typing._SpecialForm
Pattern: typing._GenericAlias
PrivateAttr: cython_function_or_method
Required: ellipsis
SHAPE_DEFAULTDICT: int
SHAPE_DEQUE: int
SHAPE_DICT: int
SHAPE_FROZENSET: int
SHAPE_GENERIC: int
SHAPE_ITERABLE: int
SHAPE_LIST: int
SHAPE_MAPPING: int
SHAPE_NAME_LOOKUP: dict
SHAPE_SEQUENCE: int
SHAPE_SET: int
SHAPE_SINGLETON: int
SHAPE_TUPLE: int
SHAPE_TUPLE_ELLIPSIS: int
Sequence: typing._GenericAlias
Set: typing._GenericAlias
T: typing.TypeVar
TYPE_CHECKING: bool
Tuple: typing._VariadicGenericAlias
Type: typing._GenericAlias
Undefined: UndefinedType
Union: typing._SpecialForm
constant_validator: cython_function_or_method
dict_validator: cython_function_or_method
display_as_type: cython_function_or_method
find_validators: cython_function_or_method
get_args: cython_function_or_method
get_origin: cython_function_or_method
is_literal_type: cython_function_or_method
is_new_type: cython_function_or_method
is_typeddict: cython_function_or_method
lenient_issubclass: cython_function_or_method
make_generic_validator: cython_function_or_method
new_type_supertype: cython_function_or_method
prep_validators: cython_function_or_method
sequence_like: cython_function_or_method
smart_deepcopy: cython_function_or_method
validate_json: cython_function_or_method

class Annotated:
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def __class_getitem__(self, *args, **kwargs) -> Any: ...
    @classmethod
    def __init_subclass__(self, *args, **kwargs) -> Any: ...

class Callable:
    _abc_impl: ClassVar[_abc_data] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    __call__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...
    @classmethod
    def __subclasshook__(self, *args, **kwargs) -> Any: ...

class CollectionsIterable:
    _abc_impl: ClassVar[_abc_data] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    __iter__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...
    @classmethod
    def __subclasshook__(self, *args, **kwargs) -> Any: ...

class ConfigError(RuntimeError): ...

class DeferredType: ...

class ErrorWrapper(pydantic.utils.Representation):
    _loc: ClassVar[member_descriptor] = ...
    exc: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def loc_tuple(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...

class FieldInfo(pydantic.utils.Representation):
    alias: ClassVar[member_descriptor] = ...
    alias_priority: ClassVar[member_descriptor] = ...
    allow_mutation: ClassVar[member_descriptor] = ...
    const: ClassVar[member_descriptor] = ...
    default: ClassVar[member_descriptor] = ...
    default_factory: ClassVar[member_descriptor] = ...
    description: ClassVar[member_descriptor] = ...
    extra: ClassVar[member_descriptor] = ...
    ge: ClassVar[member_descriptor] = ...
    gt: ClassVar[member_descriptor] = ...
    le: ClassVar[member_descriptor] = ...
    lt: ClassVar[member_descriptor] = ...
    max_items: ClassVar[member_descriptor] = ...
    max_length: ClassVar[member_descriptor] = ...
    min_items: ClassVar[member_descriptor] = ...
    min_length: ClassVar[member_descriptor] = ...
    multiple_of: ClassVar[member_descriptor] = ...
    regex: ClassVar[member_descriptor] = ...
    title: ClassVar[member_descriptor] = ...
    __field_constraints__: ClassVar[dict] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _validate(self, *args, **kwargs) -> Any: ...
    def get_constraints(self, *args, **kwargs) -> Any: ...
    def update_from_config(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...

class ForwardRef(typing._Final):
    __init__: ClassVar[function] = ...
    _evaluate: ClassVar[function] = ...
    __eq__: ClassVar[function] = ...
    __forward_arg__: ClassVar[member_descriptor] = ...
    __forward_code__: ClassVar[member_descriptor] = ...
    __forward_evaluated__: ClassVar[member_descriptor] = ...
    __forward_is_argument__: ClassVar[member_descriptor] = ...
    __forward_value__: ClassVar[member_descriptor] = ...
    __hash__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...

class Json:
    @classmethod
    def __modify_schema__(self, *args, **kwargs) -> Any: ...

class JsonWrapper: ...

class ModelField(pydantic.utils.Representation):
    alias: ClassVar[member_descriptor] = ...
    allow_none: ClassVar[member_descriptor] = ...
    class_validators: ClassVar[member_descriptor] = ...
    default: ClassVar[member_descriptor] = ...
    default_factory: ClassVar[member_descriptor] = ...
    field_info: ClassVar[member_descriptor] = ...
    has_alias: ClassVar[member_descriptor] = ...
    key_field: ClassVar[member_descriptor] = ...
    model_config: ClassVar[member_descriptor] = ...
    name: ClassVar[member_descriptor] = ...
    outer_type_: ClassVar[member_descriptor] = ...
    parse_json: ClassVar[member_descriptor] = ...
    post_validators: ClassVar[member_descriptor] = ...
    pre_validators: ClassVar[member_descriptor] = ...
    required: ClassVar[member_descriptor] = ...
    shape: ClassVar[member_descriptor] = ...
    sub_fields: ClassVar[member_descriptor] = ...
    type_: ClassVar[member_descriptor] = ...
    validate_always: ClassVar[member_descriptor] = ...
    validators: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _apply_validators(self, *args, **kwargs) -> Any: ...
    def _create_sub_type(self, *args, **kwargs) -> Any: ...
    def _get_field_info(self, *args, **kwargs) -> Any: ...
    def _get_mapping_value(self, *args, **kwargs) -> Any: ...
    def _set_default_and_type(self, *args, **kwargs) -> Any: ...
    def _type_analysis(self, *args, **kwargs) -> Any: ...
    def _type_display(self, *args, **kwargs) -> Any: ...
    def _validate_iterable(self, *args, **kwargs) -> Any: ...
    def _validate_mapping_like(self, *args, **kwargs) -> Any: ...
    def _validate_sequence_like(self, *args, **kwargs) -> Any: ...
    def _validate_singleton(self, *args, **kwargs) -> Any: ...
    def _validate_tuple(self, *args, **kwargs) -> Any: ...
    def get_default(self, *args, **kwargs) -> Any: ...
    @classmethod
    def infer(self, *args, **kwargs) -> Any: ...
    def is_complex(self, *args, **kwargs) -> Any: ...
    def populate_validators(self, *args, **kwargs) -> Any: ...
    def prepare(self, *args, **kwargs) -> Any: ...
    def set_config(self, *args, **kwargs) -> Any: ...
    def validate(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    @property
    def alt_alias(self) -> Any: ...

class ModelPrivateAttr(pydantic.utils.Representation):
    default: ClassVar[member_descriptor] = ...
    default_factory: ClassVar[member_descriptor] = ...
    __hash__: ClassVar[None] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get_default(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...

class NoneIsNotAllowedError(pydantic.errors.PydanticTypeError):
    code: ClassVar[str] = ...
    msg_template: ClassVar[str] = ...

class NoneType:
    @classmethod
    def __init__(self, *args, **kwargs) -> None: ...
    def __bool__(self) -> Any: ...

class PyObjectStr(str): ...

class Representation:
    __slots__: ClassVar[tuple] = ...
    def __pretty__(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    def __repr_name__(self, *args, **kwargs) -> Any: ...
    def __repr_str__(self, *args, **kwargs) -> Any: ...

class TypeVar(typing._Final, typing._Immutable):
    __init__: ClassVar[function] = ...
    __bound__: ClassVar[member_descriptor] = ...
    __constraints__: ClassVar[member_descriptor] = ...
    __contravariant__: ClassVar[member_descriptor] = ...
    __covariant__: ClassVar[member_descriptor] = ...
    __name__: ClassVar[member_descriptor] = ...
    __reduce__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...

class UndefinedType:
    def __copy__(self) -> Any: ...
    def __deepcopy__(self) -> Any: ...
    def __reduce__(self) -> Any: ...

class Validator:
    always: ClassVar[member_descriptor] = ...
    check_fields: ClassVar[member_descriptor] = ...
    each_item: ClassVar[member_descriptor] = ...
    func: ClassVar[member_descriptor] = ...
    pre: ClassVar[member_descriptor] = ...
    skip_on_failure: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class defaultdict(dict):
    default_factory: ClassVar[member_descriptor] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def copy(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> Any: ...
    def __missing__(key) -> Any: ...
    def __reduce__(self) -> Any: ...

class deque:
    maxlen: ClassVar[getset_descriptor] = ...
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, *args, **kwargs) -> Any: ...
    def appendleft(self, *args, **kwargs) -> Any: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def copy(self, *args, **kwargs) -> Any: ...
    def count(self, *args, **kwargs) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def extendleft(self, *args, **kwargs) -> Any: ...
    def index(self, *args, **kwargs) -> Any: ...
    def insert(index, object) -> Any: ...
    def pop(self, *args, **kwargs) -> Any: ...
    def popleft(self, *args, **kwargs) -> Any: ...
    def remove(value) -> Any: ...
    def reverse() -> Any: ...
    def rotate(self, *args, **kwargs) -> Any: ...
    def __add__(self, other) -> Any: ...
    def __bool__(self) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __copy__(self) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __iadd__(self, other) -> Any: ...
    def __imul__(self, other) -> Any: ...
    def __iter__(self) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __len__(self) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __mul__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __reversed__() -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...
    def __sizeof__() -> Any: ...
