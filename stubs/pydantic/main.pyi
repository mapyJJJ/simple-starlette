from typing import Any, Callable, ClassVar, Dict, List, Optional, Tuple, Union

import abc
import enum
import pathlib
import pydantic.errors
import pydantic.fields
import pydantic.parse
import pydantic.utils
import typing
ANNOTATED_FIELD_UNTOUCHED_TYPES: tuple
AbstractSet: typing._GenericAlias
Any: typing._SpecialForm
AnyCallable: typing._GenericAlias
Callable: typing._VariadicGenericAlias
Dict: typing._GenericAlias
EXTRA_LINK: str
List: typing._GenericAlias
MAPPING_LIKE_SHAPES: set
Mapping: typing._GenericAlias
Optional: typing._SpecialForm
PrivateAttr: cython_function_or_method
ROOT_KEY: str
SchemaExtraCallable: typing._GenericAlias
StrBytes: typing._GenericAlias
TYPE_CHECKING: bool
Tuple: typing._VariadicGenericAlias
Type: typing._GenericAlias
UNTOUCHED_TYPES: tuple
Undefined: pydantic.fields.UndefinedType
Union: typing._SpecialForm
_is_base_model_class_defined: bool
_missing: object
cast: function
compiled: bool
create_model: cython_function_or_method
custom_pydantic_encoder: cython_function_or_method
deepcopy: function
default_ref_template: str
extract_root_validators: cython_function_or_method
extract_validators: cython_function_or_method
generate_hash_function: cython_function_or_method
generate_model_signature: cython_function_or_method
get_args: cython_function_or_method
get_origin: cython_function_or_method
inherit_config: cython_function_or_method
inherit_validators: cython_function_or_method
is_classvar: cython_function_or_method
is_namedtuple: cython_function_or_method
is_valid_field: cython_function_or_method
is_valid_private_name: cython_function_or_method
lenient_issubclass: cython_function_or_method
load_file: cython_function_or_method
load_str_bytes: cython_function_or_method
model_schema: cython_function_or_method
no_type_check: function
object_setattr: wrapper_descriptor
overload: function
prepare_config: cython_function_or_method
pydantic_encoder: cython_function_or_method
resolve_annotations: cython_function_or_method
sequence_like: cython_function_or_method
smart_deepcopy: cython_function_or_method
unique_list: cython_function_or_method
update_field_forward_refs: cython_function_or_method
validate_custom_root_type: cython_function_or_method
validate_field_name: cython_function_or_method
validate_model: cython_function_or_method

class ABCMeta(type):
    _abc_caches_clear: ClassVar[function] = ...
    _abc_registry_clear: ClassVar[function] = ...
    _dump_registry: ClassVar[function] = ...
    register: ClassVar[function] = ...
    __instancecheck__: ClassVar[function] = ...
    __subclasscheck__: ClassVar[function] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BaseConfig:
    class getter_dict(pydantic.utils.Representation):
        _obj: ClassVar[member_descriptor] = ...
        __hash__: ClassVar[None] = ...
        __slots__: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def extra_keys(self, *args, **kwargs) -> Any: ...
        def get(self, *args, **kwargs) -> Any: ...
        def items(self, *args, **kwargs) -> Any: ...
        def keys(self, *args, **kwargs) -> Any: ...
        def values(self, *args, **kwargs) -> Any: ...
        def __contains__(self, other) -> Any: ...
        def __eq__(self, other) -> Any: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Any: ...
        def __len__(self) -> Any: ...
        def __repr_args__(self, *args, **kwargs) -> Any: ...
        def __repr_name__(self, *args, **kwargs) -> Any: ...
    alias_generator: ClassVar[None] = ...
    allow_mutation: ClassVar[bool] = ...
    allow_population_by_field_name: ClassVar[bool] = ...
    anystr_lower: ClassVar[bool] = ...
    anystr_strip_whitespace: ClassVar[bool] = ...
    arbitrary_types_allowed: ClassVar[bool] = ...
    copy_on_model_validation: ClassVar[bool] = ...
    error_msg_templates: ClassVar[dict] = ...
    extra: ClassVar[Extra] = ...
    fields: ClassVar[dict] = ...
    frozen: ClassVar[bool] = ...
    json_dumps: ClassVar[function] = ...
    json_encoders: ClassVar[dict] = ...
    json_loads: ClassVar[function] = ...
    keep_untouched: ClassVar[tuple] = ...
    max_anystr_length: ClassVar[None] = ...
    min_anystr_length: ClassVar[None] = ...
    orm_mode: ClassVar[bool] = ...
    schema_extra: ClassVar[dict] = ...
    title: ClassVar[None] = ...
    underscore_attrs_are_private: ClassVar[bool] = ...
    use_enum_values: ClassVar[bool] = ...
    validate_all: ClassVar[bool] = ...
    validate_assignment: ClassVar[bool] = ...
    @classmethod
    def get_field_info(self, *args, **kwargs) -> Any: ...
    @classmethod
    def prepare_field(self, *args, **kwargs) -> Any: ...

class BaseModel(pydantic.utils.Representation):
    class Config:
        class getter_dict(pydantic.utils.Representation):
            _obj: ClassVar[member_descriptor] = ...
            __hash__: ClassVar[None] = ...
            __slots__: ClassVar[tuple] = ...
            def __init__(self, *args, **kwargs) -> None: ...
            def extra_keys(self, *args, **kwargs) -> Any: ...
            def get(self, *args, **kwargs) -> Any: ...
            def items(self, *args, **kwargs) -> Any: ...
            def keys(self, *args, **kwargs) -> Any: ...
            def values(self, *args, **kwargs) -> Any: ...
            def __contains__(self, other) -> Any: ...
            def __eq__(self, other) -> Any: ...
            def __getitem__(self, index) -> Any: ...
            def __iter__(self) -> Any: ...
            def __len__(self) -> Any: ...
            def __repr_args__(self, *args, **kwargs) -> Any: ...
            def __repr_name__(self, *args, **kwargs) -> Any: ...
        alias_generator: ClassVar[None] = ...
        allow_mutation: ClassVar[bool] = ...
        allow_population_by_field_name: ClassVar[bool] = ...
        anystr_lower: ClassVar[bool] = ...
        anystr_strip_whitespace: ClassVar[bool] = ...
        arbitrary_types_allowed: ClassVar[bool] = ...
        copy_on_model_validation: ClassVar[bool] = ...
        error_msg_templates: ClassVar[dict] = ...
        extra: ClassVar[Extra] = ...
        fields: ClassVar[dict] = ...
        frozen: ClassVar[bool] = ...
        json_dumps: ClassVar[function] = ...
        json_encoders: ClassVar[dict] = ...
        json_loads: ClassVar[function] = ...
        keep_untouched: ClassVar[tuple] = ...
        max_anystr_length: ClassVar[None] = ...
        min_anystr_length: ClassVar[None] = ...
        orm_mode: ClassVar[bool] = ...
        schema_extra: ClassVar[dict] = ...
        title: ClassVar[None] = ...
        underscore_attrs_are_private: ClassVar[bool] = ...
        use_enum_values: ClassVar[bool] = ...
        validate_all: ClassVar[bool] = ...
        validate_assignment: ClassVar[bool] = ...
        @classmethod
        def get_field_info(self, *args, **kwargs) -> Any: ...
        @classmethod
        def prepare_field(self, *args, **kwargs) -> Any: ...

    class __config__(BaseConfig):
        json_encoders: ClassVar[dict] = ...
    _abc_impl: ClassVar[_abc_data] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    __class_vars__: ClassVar[set] = ...
    __custom_root_type__: ClassVar[bool] = ...
    __fields__: ClassVar[dict] = ...
    __fields_set__: ClassVar[member_descriptor] = ...
    __hash__: ClassVar[None] = ...
    __post_root_validators__: ClassVar[list] = ...
    __pre_root_validators__: ClassVar[list] = ...
    __private_attributes__: ClassVar[dict] = ...
    __schema_cache__: ClassVar[dict] = ...
    __slots__: ClassVar[set] = ...
    __validators__: ClassVar[dict] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _calculate_keys(self, *args, **kwargs) -> Any: ...
    @classmethod
    def _decompose_class(self, *args, **kwargs) -> Any: ...
    @classmethod
    def _enforce_dict_if_root(self, *args, **kwargs) -> Any: ...
    @classmethod
    def _get_value(self, *args, **kwargs) -> Any: ...
    def _init_private_attributes(self, *args, **kwargs) -> Any: ...
    def _iter(self, *args, **kwargs) -> Any: ...
    @classmethod
    def construct(self, *args, **kwargs) -> Any: ...
    def copy(self, *args, **kwargs) -> Any: ...
    def dict(self, *args, **kwargs) -> Any: ...
    @classmethod
    def from_orm(self, *args, **kwargs) -> Any: ...
    def json(self, *args, **kwargs) -> Any: ...
    @classmethod
    def parse_file(self, *args, **kwargs) -> Any: ...
    @classmethod
    def parse_obj(self, *args, **kwargs) -> Any: ...
    @classmethod
    def parse_raw(self, *args, **kwargs) -> Any: ...
    @classmethod
    def schema(self, *args, **kwargs) -> Any: ...
    @classmethod
    def schema_json(self, *args, **kwargs) -> Any: ...
    @classmethod
    def update_forward_refs(self, *args, **kwargs) -> Any: ...
    @classmethod
    def validate(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...
    @classmethod
    def __get_validators__(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __iter__(self) -> Any: ...
    def __json_encoder__(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    def __setattr__(self, name, value) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __signature__(self, *args, **kwargs) -> Any: ...

class ClassAttribute:
    name: ClassVar[member_descriptor] = ...
    value: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __get__(self, instance, owner) -> Any: ...

class ConfigError(RuntimeError): ...

class DictError(pydantic.errors.PydanticTypeError):
    msg_template: ClassVar[str] = ...

class Enum:
    class _member_type_:
        __class__: ClassVar[getset_descriptor] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def __delattr__(self, name) -> Any: ...
        def __dir__(self) -> Any: ...
        def __eq__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> Any: ...
        def __gt__(self, other) -> Any: ...
        def __hash__(self) -> Any: ...
        @classmethod
        def __init_subclass__(self, *args, **kwargs) -> Any: ...
        def __le__(self, other) -> Any: ...
        def __lt__(self, other) -> Any: ...
        def __ne__(self, other) -> Any: ...
        def __reduce__(self) -> Any: ...
        def __reduce_ex__(self, protocol) -> Any: ...
        def __setattr__(self, name, value) -> Any: ...
        def __sizeof__(self) -> Any: ...
        @classmethod
        def __subclasshook__(self, *args, **kwargs) -> Any: ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...
    __dir__: ClassVar[function] = ...
    __format__: ClassVar[function] = ...
    __hash__: ClassVar[function] = ...
    __reduce_ex__: ClassVar[function] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def _missing_(self, *args, **kwargs) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def value(self) -> Any: ...

class ErrorWrapper(pydantic.utils.Representation):
    _loc: ClassVar[member_descriptor] = ...
    exc: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def loc_tuple(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...

class Extra(str, enum.Enum):
    class _member_type_:
        @classmethod
        def __init__(self, *args, **kwargs) -> None: ...
        def capitalize(self, *args, **kwargs) -> Any: ...
        def casefold(self, *args, **kwargs) -> Any: ...
        def center(self, *args, **kwargs) -> Any: ...
        def count(self, *args, **kwargs) -> Any: ...
        def encode(self, *args, **kwargs) -> Any: ...
        def endswith(self, *args, **kwargs) -> Any: ...
        def expandtabs(self, *args, **kwargs) -> Any: ...
        def find(self, *args, **kwargs) -> Any: ...
        def format(*args, **kwargs) -> str: ...
        def format_map(mapping) -> str: ...
        def index(self, *args, **kwargs) -> Any: ...
        def isalnum(self, *args, **kwargs) -> Any: ...
        def isalpha(self, *args, **kwargs) -> Any: ...
        def isascii(self, *args, **kwargs) -> Any: ...
        def isdecimal(self, *args, **kwargs) -> Any: ...
        def isdigit(self, *args, **kwargs) -> Any: ...
        def isidentifier(self, *args, **kwargs) -> Any: ...
        def islower(self, *args, **kwargs) -> Any: ...
        def isnumeric(self, *args, **kwargs) -> Any: ...
        def isprintable(self, *args, **kwargs) -> Any: ...
        def isspace(self, *args, **kwargs) -> Any: ...
        def istitle(self, *args, **kwargs) -> Any: ...
        def isupper(self, *args, **kwargs) -> Any: ...
        def join(self, *args, **kwargs) -> Any: ...
        def ljust(self, *args, **kwargs) -> Any: ...
        def lower(self, *args, **kwargs) -> Any: ...
        def lstrip(self, *args, **kwargs) -> Any: ...
        def maketrans(self, *args, **kwargs) -> Any: ...
        def partition(self, *args, **kwargs) -> Any: ...
        def replace(self, *args, **kwargs) -> Any: ...
        def rfind(self, *args, **kwargs) -> Any: ...
        def rindex(self, *args, **kwargs) -> Any: ...
        def rjust(self, *args, **kwargs) -> Any: ...
        def rpartition(self, *args, **kwargs) -> Any: ...
        def rsplit(self, *args, **kwargs) -> Any: ...
        def rstrip(self, *args, **kwargs) -> Any: ...
        def split(self, *args, **kwargs) -> Any: ...
        def splitlines(self, *args, **kwargs) -> Any: ...
        def startswith(self, *args, **kwargs) -> Any: ...
        def strip(self, *args, **kwargs) -> Any: ...
        def swapcase(self, *args, **kwargs) -> Any: ...
        def title(self, *args, **kwargs) -> Any: ...
        def translate(self, *args, **kwargs) -> Any: ...
        def upper(self, *args, **kwargs) -> Any: ...
        def zfill(self, *args, **kwargs) -> Any: ...
        def __add__(self, other) -> Any: ...
        def __contains__(self, other) -> Any: ...
        def __eq__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> Any: ...
        def __getitem__(self, index) -> Any: ...
        def __getnewargs__(self, *args, **kwargs) -> Any: ...
        def __gt__(self, other) -> Any: ...
        def __hash__(self) -> Any: ...
        def __iter__(self) -> Any: ...
        def __le__(self, other) -> Any: ...
        def __len__(self) -> Any: ...
        def __lt__(self, other) -> Any: ...
        def __mod__(self, other) -> Any: ...
        def __mul__(self, other) -> Any: ...
        def __ne__(self, other) -> Any: ...
        def __rmod__(self, other) -> Any: ...
        def __rmul__(self, other) -> Any: ...
        def __sizeof__(self) -> Any: ...
    __new__: ClassVar[function] = ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...
    allow: ClassVar[Extra] = ...
    forbid: ClassVar[Extra] = ...
    ignore: ClassVar[Extra] = ...
    __format__: ClassVar[function] = ...

class ExtraError(pydantic.errors.PydanticValueError):
    msg_template: ClassVar[str] = ...

class FunctionType:
    __annotations__: ClassVar[getset_descriptor] = ...
    __closure__: ClassVar[member_descriptor] = ...
    __code__: ClassVar[getset_descriptor] = ...
    __defaults__: ClassVar[getset_descriptor] = ...
    __globals__: ClassVar[member_descriptor] = ...
    __kwdefaults__: ClassVar[getset_descriptor] = ...
    __name__: ClassVar[getset_descriptor] = ...
    __qualname__: ClassVar[getset_descriptor] = ...
    @classmethod
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __get__(self, instance, owner) -> Any: ...

class GetterDict(pydantic.utils.Representation):
    _obj: ClassVar[member_descriptor] = ...
    __hash__: ClassVar[None] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def extra_keys(self, *args, **kwargs) -> Any: ...
    def get(self, *args, **kwargs) -> Any: ...
    def items(self, *args, **kwargs) -> Any: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def values(self, *args, **kwargs) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    def __repr_name__(self, *args, **kwargs) -> Any: ...

class MissingError(pydantic.errors.PydanticValueError):
    msg_template: ClassVar[str] = ...

class ModelField(pydantic.utils.Representation):
    alias: ClassVar[member_descriptor] = ...
    allow_none: ClassVar[member_descriptor] = ...
    class_validators: ClassVar[member_descriptor] = ...
    default: ClassVar[member_descriptor] = ...
    default_factory: ClassVar[member_descriptor] = ...
    field_info: ClassVar[member_descriptor] = ...
    has_alias: ClassVar[member_descriptor] = ...
    key_field: ClassVar[member_descriptor] = ...
    model_config: ClassVar[member_descriptor] = ...
    name: ClassVar[member_descriptor] = ...
    outer_type_: ClassVar[member_descriptor] = ...
    parse_json: ClassVar[member_descriptor] = ...
    post_validators: ClassVar[member_descriptor] = ...
    pre_validators: ClassVar[member_descriptor] = ...
    required: ClassVar[member_descriptor] = ...
    shape: ClassVar[member_descriptor] = ...
    sub_fields: ClassVar[member_descriptor] = ...
    type_: ClassVar[member_descriptor] = ...
    validate_always: ClassVar[member_descriptor] = ...
    validators: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _apply_validators(self, *args, **kwargs) -> Any: ...
    def _create_sub_type(self, *args, **kwargs) -> Any: ...
    def _get_field_info(self, *args, **kwargs) -> Any: ...
    def _get_mapping_value(self, *args, **kwargs) -> Any: ...
    def _set_default_and_type(self, *args, **kwargs) -> Any: ...
    def _type_analysis(self, *args, **kwargs) -> Any: ...
    def _type_display(self, *args, **kwargs) -> Any: ...
    def _validate_iterable(self, *args, **kwargs) -> Any: ...
    def _validate_mapping_like(self, *args, **kwargs) -> Any: ...
    def _validate_sequence_like(self, *args, **kwargs) -> Any: ...
    def _validate_singleton(self, *args, **kwargs) -> Any: ...
    def _validate_tuple(self, *args, **kwargs) -> Any: ...
    def get_default(self, *args, **kwargs) -> Any: ...
    @classmethod
    def infer(self, *args, **kwargs) -> Any: ...
    def is_complex(self, *args, **kwargs) -> Any: ...
    def populate_validators(self, *args, **kwargs) -> Any: ...
    def prepare(self, *args, **kwargs) -> Any: ...
    def set_config(self, *args, **kwargs) -> Any: ...
    def validate(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    @property
    def alt_alias(self) -> Any: ...

class ModelMetaclass(abc.ABCMeta):
    def __init__(self, *args, **kwargs) -> None: ...

class ModelPrivateAttr(pydantic.utils.Representation):
    default: ClassVar[member_descriptor] = ...
    default_factory: ClassVar[member_descriptor] = ...
    __hash__: ClassVar[None] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get_default(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...

class Path(pathlib.PurePath):
    _accessor: ClassVar[member_descriptor] = ...
    _closed: ClassVar[member_descriptor] = ...
    _init: ClassVar[function] = ...
    _make_child_relpath: ClassVar[function] = ...
    _opener: ClassVar[function] = ...
    _raise_closed: ClassVar[function] = ...
    _raw_open: ClassVar[function] = ...
    absolute: ClassVar[function] = ...
    chmod: ClassVar[function] = ...
    exists: ClassVar[function] = ...
    expanduser: ClassVar[function] = ...
    glob: ClassVar[function] = ...
    group: ClassVar[function] = ...
    is_block_device: ClassVar[function] = ...
    is_char_device: ClassVar[function] = ...
    is_dir: ClassVar[function] = ...
    is_fifo: ClassVar[function] = ...
    is_file: ClassVar[function] = ...
    is_mount: ClassVar[function] = ...
    is_socket: ClassVar[function] = ...
    is_symlink: ClassVar[function] = ...
    iterdir: ClassVar[function] = ...
    lchmod: ClassVar[function] = ...
    link_to: ClassVar[function] = ...
    lstat: ClassVar[function] = ...
    mkdir: ClassVar[function] = ...
    open: ClassVar[function] = ...
    owner: ClassVar[function] = ...
    read_bytes: ClassVar[function] = ...
    read_text: ClassVar[function] = ...
    rename: ClassVar[function] = ...
    replace: ClassVar[function] = ...
    resolve: ClassVar[function] = ...
    rglob: ClassVar[function] = ...
    rmdir: ClassVar[function] = ...
    samefile: ClassVar[function] = ...
    stat: ClassVar[function] = ...
    symlink_to: ClassVar[function] = ...
    touch: ClassVar[function] = ...
    unlink: ClassVar[function] = ...
    write_bytes: ClassVar[function] = ...
    write_text: ClassVar[function] = ...
    __enter__: ClassVar[function] = ...
    __exit__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def cwd(self, *args, **kwargs) -> Any: ...
    @classmethod
    def home(self, *args, **kwargs) -> Any: ...

class Protocol(str, enum.Enum):
    class _member_type_:
        @classmethod
        def __init__(self, *args, **kwargs) -> None: ...
        def capitalize(self, *args, **kwargs) -> Any: ...
        def casefold(self, *args, **kwargs) -> Any: ...
        def center(self, *args, **kwargs) -> Any: ...
        def count(self, *args, **kwargs) -> Any: ...
        def encode(self, *args, **kwargs) -> Any: ...
        def endswith(self, *args, **kwargs) -> Any: ...
        def expandtabs(self, *args, **kwargs) -> Any: ...
        def find(self, *args, **kwargs) -> Any: ...
        def format(*args, **kwargs) -> str: ...
        def format_map(mapping) -> str: ...
        def index(self, *args, **kwargs) -> Any: ...
        def isalnum(self, *args, **kwargs) -> Any: ...
        def isalpha(self, *args, **kwargs) -> Any: ...
        def isascii(self, *args, **kwargs) -> Any: ...
        def isdecimal(self, *args, **kwargs) -> Any: ...
        def isdigit(self, *args, **kwargs) -> Any: ...
        def isidentifier(self, *args, **kwargs) -> Any: ...
        def islower(self, *args, **kwargs) -> Any: ...
        def isnumeric(self, *args, **kwargs) -> Any: ...
        def isprintable(self, *args, **kwargs) -> Any: ...
        def isspace(self, *args, **kwargs) -> Any: ...
        def istitle(self, *args, **kwargs) -> Any: ...
        def isupper(self, *args, **kwargs) -> Any: ...
        def join(self, *args, **kwargs) -> Any: ...
        def ljust(self, *args, **kwargs) -> Any: ...
        def lower(self, *args, **kwargs) -> Any: ...
        def lstrip(self, *args, **kwargs) -> Any: ...
        def maketrans(self, *args, **kwargs) -> Any: ...
        def partition(self, *args, **kwargs) -> Any: ...
        def replace(self, *args, **kwargs) -> Any: ...
        def rfind(self, *args, **kwargs) -> Any: ...
        def rindex(self, *args, **kwargs) -> Any: ...
        def rjust(self, *args, **kwargs) -> Any: ...
        def rpartition(self, *args, **kwargs) -> Any: ...
        def rsplit(self, *args, **kwargs) -> Any: ...
        def rstrip(self, *args, **kwargs) -> Any: ...
        def split(self, *args, **kwargs) -> Any: ...
        def splitlines(self, *args, **kwargs) -> Any: ...
        def startswith(self, *args, **kwargs) -> Any: ...
        def strip(self, *args, **kwargs) -> Any: ...
        def swapcase(self, *args, **kwargs) -> Any: ...
        def title(self, *args, **kwargs) -> Any: ...
        def translate(self, *args, **kwargs) -> Any: ...
        def upper(self, *args, **kwargs) -> Any: ...
        def zfill(self, *args, **kwargs) -> Any: ...
        def __add__(self, other) -> Any: ...
        def __contains__(self, other) -> Any: ...
        def __eq__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> Any: ...
        def __getitem__(self, index) -> Any: ...
        def __getnewargs__(self, *args, **kwargs) -> Any: ...
        def __gt__(self, other) -> Any: ...
        def __hash__(self) -> Any: ...
        def __iter__(self) -> Any: ...
        def __le__(self, other) -> Any: ...
        def __len__(self) -> Any: ...
        def __lt__(self, other) -> Any: ...
        def __mod__(self, other) -> Any: ...
        def __mul__(self, other) -> Any: ...
        def __ne__(self, other) -> Any: ...
        def __rmod__(self, other) -> Any: ...
        def __rmul__(self, other) -> Any: ...
        def __sizeof__(self) -> Any: ...
    __new__: ClassVar[function] = ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...
    json: ClassVar[pydantic.parse.Protocol] = ...
    pickle: ClassVar[pydantic.parse.Protocol] = ...
    __format__: ClassVar[function] = ...

class PyObject:
    validate_always: ClassVar[bool] = ...
    @classmethod
    def validate(self, *args, **kwargs) -> Any: ...
    @classmethod
    def __get_validators__(self, *args, **kwargs) -> Any: ...

class Representation:
    __slots__: ClassVar[tuple] = ...
    def __pretty__(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...
    def __repr_name__(self, *args, **kwargs) -> Any: ...
    def __repr_str__(self, *args, **kwargs) -> Any: ...

class TypeVar(typing._Final, typing._Immutable):
    __init__: ClassVar[function] = ...
    __bound__: ClassVar[member_descriptor] = ...
    __constraints__: ClassVar[member_descriptor] = ...
    __contravariant__: ClassVar[member_descriptor] = ...
    __covariant__: ClassVar[member_descriptor] = ...
    __name__: ClassVar[member_descriptor] = ...
    __reduce__: ClassVar[function] = ...
    __slots__: ClassVar[tuple] = ...

class ValidationError(pydantic.utils.Representation, ValueError):
    _error_cache: ClassVar[member_descriptor] = ...
    model: ClassVar[member_descriptor] = ...
    raw_errors: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def errors(self, *args, **kwargs) -> Any: ...
    def json(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...

class ValidatorGroup:
    def __init__(self, *args, **kwargs) -> None: ...
    def check_for_unused(self, *args, **kwargs) -> Any: ...
    def get_validators(self, *args, **kwargs) -> Any: ...

class ValueItems(pydantic.utils.Representation):
    _items: ClassVar[member_descriptor] = ...
    _type: ClassVar[member_descriptor] = ...
    __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _normalize_indexes(self, *args, **kwargs) -> Any: ...
    def for_element(self, *args, **kwargs) -> Any: ...
    def is_excluded(self, *args, **kwargs) -> Any: ...
    def is_included(self, *args, **kwargs) -> Any: ...
    def __repr_args__(self, *args, **kwargs) -> Any: ...

class partial:
    args: ClassVar[member_descriptor] = ...
    func: ClassVar[member_descriptor] = ...
    keywords: ClassVar[member_descriptor] = ...
    @classmethod
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __delattr__(self, name) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setattr__(self, name, value) -> Any: ...
    def __setstate__(self, state) -> Any: ...
