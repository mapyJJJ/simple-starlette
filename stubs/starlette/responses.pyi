import os
import typing
from starlette.background import BackgroundTask as BackgroundTask
from starlette.concurrency import iterate_in_threadpool as iterate_in_threadpool
from starlette.datastructures import MutableHeaders as MutableHeaders, URL as URL
from starlette.types import Receive as Receive, Scope as Scope, Send as Send
from typing import Any

def guess_type(url: typing.Union[str, os.PathLike[str]], strict: bool=...) -> typing.Tuple[typing.Optional[str], typing.Optional[str]]: ...

class Response:
    media_type: Any = ...
    charset: str = ...
    status_code: Any = ...
    background: Any = ...
    body: Any = ...
    def __init__(self, content: typing.Any=..., status_code: int=..., headers: dict=..., media_type: str=..., background: BackgroundTask=...) -> None: ...
    def render(self, content: typing.Any) -> bytes: ...
    raw_headers: Any = ...
    def init_headers(self, headers: typing.Mapping[str, str]=...) -> None: ...
    @property
    def headers(self) -> MutableHeaders: ...
    def set_cookie(self, key: str, value: str=..., max_age: int=..., expires: int=..., path: str=..., domain: str=..., secure: bool=..., httponly: bool=..., samesite: str=...) -> None: ...
    def delete_cookie(self, key: str, path: str=..., domain: str=..., secure: bool=..., httponly: bool=..., samesite: str=...) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...

class HTMLResponse(Response):
    media_type: str = ...

class PlainTextResponse(Response):
    media_type: str = ...

class JSONResponse(Response):
    media_type: str = ...
    def render(self, content: typing.Any) -> bytes: ...

class RedirectResponse(Response):
    def __init__(self, url: typing.Union[str, URL], status_code: int=..., headers: dict=..., background: BackgroundTask=...) -> None: ...

class StreamingResponse(Response):
    body_iterator: Any = ...
    status_code: Any = ...
    media_type: Any = ...
    background: Any = ...
    def __init__(self, content: typing.Any, status_code: int=..., headers: dict=..., media_type: str=..., background: BackgroundTask=...) -> None: ...
    async def listen_for_disconnect(self, receive: Receive) -> None: ...
    async def stream_response(self, send: Send) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...

class FileResponse(Response):
    chunk_size: int = ...
    path: Any = ...
    status_code: Any = ...
    filename: Any = ...
    send_header_only: Any = ...
    media_type: Any = ...
    background: Any = ...
    stat_result: Any = ...
    def __init__(self, path: typing.Union[str, os.PathLike[str]], status_code: int=..., headers: dict=..., media_type: str=..., background: BackgroundTask=..., filename: str=..., stat_result: os.stat_result=..., method: str=...) -> None: ...
    def set_stat_headers(self, stat_result: os.stat_result) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...
