import anyio.abc
import requests
import typing
from concurrent.futures import Future
from starlette.types import Message as Message, Receive as Receive, Scope as Scope, Send as Send
from starlette.websockets import WebSocketDisconnect as WebSocketDisconnect
from typing import Any
from typing_extensions import TypedDict

Cookies: Any
Params: Any
DataType: Any
TimeOut: Any
FileType: Any
AuthType: Any
ASGIInstance: Any
ASGI2App: Any
ASGI3App: Any

class _HeaderDict(requests.packages.urllib3._collections.HTTPHeaderDict):
    def get_all(self, key: str, default: str) -> str: ...

class _MockOriginalResponse:
    msg: Any = ...
    closed: bool = ...
    def __init__(self, headers: typing.List[typing.Tuple[bytes, bytes]]) -> None: ...
    def isclosed(self) -> bool: ...

class _Upgrade(Exception):
    session: Any = ...
    def __init__(self, session: WebSocketTestSession) -> None: ...

class _WrapASGI2:
    app: Any = ...
    def __init__(self, app: ASGI2App) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...

class _AsyncBackend(TypedDict):
    backend: str
    backend_options: typing.Dict[str, typing.Any]

class _ASGIAdapter(requests.adapters.HTTPAdapter):
    app: Any = ...
    raise_server_exceptions: Any = ...
    root_path: Any = ...
    portal_factory: Any = ...
    def __init__(self, app: ASGI3App, portal_factory: _PortalFactoryType, raise_server_exceptions: bool=..., root_path: str=...) -> None: ...
    def send(self, request: requests.PreparedRequest, *args: typing.Any, **kwargs: typing.Any) -> requests.Response: ...

class WebSocketTestSession:
    app: Any = ...
    scope: Any = ...
    accepted_subprotocol: Any = ...
    portal_factory: Any = ...
    def __init__(self, app: ASGI3App, scope: Scope, portal_factory: _PortalFactoryType) -> None: ...
    exit_stack: Any = ...
    portal: Any = ...
    def __enter__(self) -> WebSocketTestSession: ...
    def __exit__(self, *args: typing.Any) -> None: ...
    def send(self, message: Message) -> None: ...
    def send_text(self, data: str) -> None: ...
    def send_bytes(self, data: bytes) -> None: ...
    def send_json(self, data: typing.Any, mode: str=...) -> None: ...
    def close(self, code: int=...) -> None: ...
    def receive(self) -> Message: ...
    def receive_text(self) -> str: ...
    def receive_bytes(self) -> bytes: ...
    def receive_json(self, mode: str=...) -> typing.Any: ...

class TestClient(requests.Session):
    __test__: bool = ...
    task: Future[None]
    portal: typing.Optional[anyio.abc.BlockingPortal] = ...
    async_backend: Any = ...
    app: Any = ...
    base_url: Any = ...
    def __init__(self, app: typing.Union[ASGI2App, ASGI3App], base_url: str=..., raise_server_exceptions: bool=..., root_path: str=..., backend: str=..., backend_options: typing.Optional[typing.Dict[str, typing.Any]]=...) -> None: ...
    def request(self, method: str, url: str, params: Params=..., data: DataType=..., headers: typing.MutableMapping[str, str]=..., cookies: Cookies=..., files: FileType=..., auth: AuthType=..., timeout: TimeOut=..., allow_redirects: bool=..., proxies: typing.MutableMapping[str, str]=..., hooks: typing.Any=..., stream: bool=..., verify: typing.Union[bool, str]=..., cert: typing.Union[str, typing.Tuple[str, str]]=..., json: typing.Any=...) -> requests.Response: ...
    def websocket_connect(self, url: str, subprotocols: typing.Sequence[str]=..., **kwargs: typing.Any) -> typing.Any: ...
    stream_send: Any = ...
    stream_receive: Any = ...
    exit_stack: Any = ...
    def __enter__(self) -> TestClient: ...
    def __exit__(self, *args: typing.Any) -> None: ...
    async def lifespan(self) -> None: ...
    async def wait_startup(self) -> None: ...
    async def wait_shutdown(self) -> None: ...
