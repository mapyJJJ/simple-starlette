"""
This type stub file was generated by pyright.
"""

import io
import sys
import typing as t

CYGWIN = ...
MSYS2 = ...
APP_ENGINE = ...
WIN = ...
auto_wrap_for_ansi: t.Optional[t.Callable[[t.TextIO], t.TextIO]] = ...
_ansi_re = ...
def get_filesystem_encoding() -> str:
    ...

def is_ascii_encoding(encoding: str) -> bool:
    """Checks if a given encoding is ascii."""
    ...

def get_best_encoding(stream: t.IO) -> str:
    """Returns the default stream encoding if not found."""
    ...

class _NonClosingTextIOWrapper(io.TextIOWrapper):
    def __init__(self, stream: t.BinaryIO, encoding: t.Optional[str], errors: t.Optional[str], force_readable: bool = ..., force_writable: bool = ..., **extra: t.Any) -> None:
        ...
    
    def __del__(self) -> None:
        ...
    
    def isatty(self) -> bool:
        ...
    


class _FixupStream:
    """The new io interface needs more from streams than streams
    traditionally implement.  As such, this fix-up code is necessary in
    some circumstances.

    The forcing of readable and writable flags are there because some tools
    put badly patched objects on sys (one such offender are certain version
    of jupyter notebook).
    """
    def __init__(self, stream: t.BinaryIO, force_readable: bool = ..., force_writable: bool = ...) -> None:
        ...
    
    def __getattr__(self, name: str) -> t.Any:
        ...
    
    def read1(self, size: int) -> bytes:
        ...
    
    def readable(self) -> bool:
        ...
    
    def writable(self) -> bool:
        ...
    
    def seekable(self) -> bool:
        ...
    


def get_binary_stdin() -> t.BinaryIO:
    ...

def get_binary_stdout() -> t.BinaryIO:
    ...

def get_binary_stderr() -> t.BinaryIO:
    ...

def get_text_stdin(encoding: t.Optional[str] = ..., errors: t.Optional[str] = ...) -> t.TextIO:
    ...

def get_text_stdout(encoding: t.Optional[str] = ..., errors: t.Optional[str] = ...) -> t.TextIO:
    ...

def get_text_stderr(encoding: t.Optional[str] = ..., errors: t.Optional[str] = ...) -> t.TextIO:
    ...

def open_stream(filename: str, mode: str = ..., encoding: t.Optional[str] = ..., errors: t.Optional[str] = ..., atomic: bool = ...) -> t.Tuple[t.IO, bool]:
    ...

class _AtomicFile:
    def __init__(self, f: t.IO, tmp_filename: str, real_filename: str) -> None:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    def close(self, delete: bool = ...) -> None:
        ...
    
    def __getattr__(self, name: str) -> t.Any:
        ...
    
    def __enter__(self) -> _AtomicFile:
        ...
    
    def __exit__(self, exc_type, exc_value, tb): # -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    


def strip_ansi(value: str) -> str:
    ...

def should_strip_ansi(stream: t.Optional[t.IO] = ..., color: t.Optional[bool] = ...) -> bool:
    ...

if sys.platform.startswith("win") and WIN:
    _ansi_stream_wrappers: t.MutableMapping[t.TextIO, t.TextIO] = ...
    def auto_wrap_for_ansi(stream: t.TextIO, color: t.Optional[bool] = ...) -> t.TextIO:
        """Support ANSI color and style codes on Windows by wrapping a
        stream with colorama.
        """
        ...
    
else:
    ...
def term_len(x: str) -> int:
    ...

def isatty(stream: t.IO) -> bool:
    ...

_default_text_stdin = ...
_default_text_stdout = ...
_default_text_stderr = ...
binary_streams: t.Mapping[str, t.Callable[[], t.BinaryIO]] = ...
text_streams: t.Mapping[str, t.Callable[[t.Optional[str], t.Optional[str]], t.TextIO]] = ...
