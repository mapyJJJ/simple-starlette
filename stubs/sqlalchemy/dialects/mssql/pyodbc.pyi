from ... import exc as exc, types as sqltypes, util as util
from ...connectors.pyodbc import PyODBCConnector as PyODBCConnector
from .base import BINARY as BINARY, DATETIMEOFFSET as DATETIMEOFFSET, MSDialect as MSDialect, MSExecutionContext as MSExecutionContext, VARBINARY as VARBINARY
from typing import Any, Optional

class _ms_numeric_pyodbc:
    def bind_processor(self, dialect: Any): ...

class _MSNumeric_pyodbc(_ms_numeric_pyodbc, sqltypes.Numeric): ...
class _MSFloat_pyodbc(_ms_numeric_pyodbc, sqltypes.Float): ...

class _ms_binary_pyodbc:
    def bind_processor(self, dialect: Any): ...

class _ODBCDateTimeBindProcessor:
    has_tz: bool = ...
    def bind_processor(self, dialect: Any): ...

class _ODBCDateTime(_ODBCDateTimeBindProcessor, sqltypes.DateTime): ...

class _ODBCDATETIMEOFFSET(_ODBCDateTimeBindProcessor, DATETIMEOFFSET):
    has_tz: bool = ...

class _VARBINARY_pyodbc(_ms_binary_pyodbc, VARBINARY): ...
class _BINARY_pyodbc(_ms_binary_pyodbc, BINARY): ...

class MSExecutionContext_pyodbc(MSExecutionContext):
    def pre_exec(self) -> None: ...
    def post_exec(self) -> None: ...

class MSDialect_pyodbc(PyODBCConnector, MSDialect):
    supports_statement_cache: bool = ...
    supports_sane_rowcount_returning: bool = ...
    execution_ctx_cls: Any = ...
    colspecs: Any = ...
    description_encoding: Any = ...
    use_scope_identity: Any = ...
    fast_executemany: Any = ...
    def __init__(self, description_encoding: Optional[Any] = ..., fast_executemany: bool = ..., **params: Any) -> None: ...
    def on_connect(self): ...
    def do_executemany(self, cursor: Any, statement: Any, parameters: Any, context: Optional[Any] = ...) -> None: ...
    def is_disconnect(self, e: Any, connection: Any, cursor: Any): ...
dialect = MSDialect_pyodbc
