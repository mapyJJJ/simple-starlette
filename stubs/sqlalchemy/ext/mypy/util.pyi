from mypy.nodes import CallExpr, ClassDef as ClassDef, Context as Context, Expression as Expression, JsonDict as JsonDict, NameExpr, Statement as Statement, TypeInfo
from mypy.plugin import ClassDefContext as ClassDefContext, DynamicClassDefContext as DynamicClassDefContext, SemanticAnalyzerPluginInterface as SemanticAnalyzerPluginInterface
from mypy.types import Type as Type
from typing import Any, Iterable, Iterator, List, Optional, Tuple, Type as TypingType, Union, overload

class SQLAlchemyAttribute:
    name: Any = ...
    line: Any = ...
    column: Any = ...
    type: Any = ...
    info: Any = ...
    def __init__(self, name: str, line: int, column: int, typ: Optional[Type], info: TypeInfo) -> None: ...
    def serialize(self) -> JsonDict: ...
    def expand_typevar_from_subtype(self, sub_type: TypeInfo) -> None: ...
    @classmethod
    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -> SQLAlchemyAttribute: ...

def establish_as_sqlalchemy(info: TypeInfo) -> None: ...
def set_is_base(info: TypeInfo) -> None: ...
def get_is_base(info: TypeInfo) -> bool: ...
def has_declarative_base(info: TypeInfo) -> bool: ...
def set_has_table(info: TypeInfo) -> None: ...
def get_has_table(info: TypeInfo) -> bool: ...
def get_mapped_attributes(info: TypeInfo, api: SemanticAnalyzerPluginInterface) -> Optional[List[SQLAlchemyAttribute]]: ...
def set_mapped_attributes(info: TypeInfo, attributes: List[SQLAlchemyAttribute]) -> None: ...
def fail(api: SemanticAnalyzerPluginInterface, msg: str, ctx: Context) -> None: ...
def add_global(ctx: Union[ClassDefContext, DynamicClassDefContext], module: str, symbol_name: str, asname: str) -> None: ...
@overload
def get_callexpr_kwarg(callexpr: CallExpr, name: str, *, expr_types: None=...) -> Optional[Union[CallExpr, NameExpr]]: ...
@overload
def get_callexpr_kwarg(callexpr: CallExpr, name: str, expr_types: Tuple[TypingType[_TArgType], ...]) -> Optional[_TArgType]: ...
def flatten_typechecking(stmts: Iterable[Statement]) -> Iterator[Statement]: ...
def unbound_to_instance(api: SemanticAnalyzerPluginInterface, typ: Type) -> Type: ...
def info_for_cls(cls, api: SemanticAnalyzerPluginInterface) -> Optional[TypeInfo]: ...
def expr_to_mapped_constructor(expr: Expression) -> CallExpr: ...
